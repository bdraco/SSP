#!/usr/bin/perl

# SSP - System Status Probe
# Find and print useful troubleshooting info on cPanel servers

use strict;
use warnings;
use File::Find;
use IO::Socket::INET;
use Sys::Hostname;
use Term::ANSIColor qw(:constants);
use Storable;
use POSIX;
use Time::Local;


######################
##  BEGIN GLOBALS   ##
######################

my $cpanel_version        = get_cpanel_version();
my ( $cpanel_version_major, $cpanel_version_minor ) = split /\./, $cpanel_version;
my $hostname              = hostname();
my $os                    = get_os();
my $is_cloudlinux         = 0;
my $external_ip_address;
my $TIERS                 = get_tiers_file();
my @local_ipaddrs_list    = get_local_ipaddrs();
my @process_list          = get_process_list();
my %hostinfo              = get_hostinfo();
my %cpuinfo               = get_cpuinfo();
my $mysql_datadir         = get_mysql_datadir();
my $mysql_error_log       = get_mysql_error_log();
my @mysql_rpm_versions;        # certain installed rpms that begin with MySQL- (e.g., MySQL-server, etc)
my @usr_local_cpanel_hooks;    # items in /usr/local/cpanel/hooks/
my @extended_rpm_list;         # rpm -qa --queryformat '%{ARCH}\t%{NAME}\t%{VERSION}\t%{RELEASE}\n'
my @rpm_list;                  # rpm -qa
my %cpconf;                    # cpanel.config
my %pureftpdconf;              # /etc/pure-ftpd.conf
my @apache_version_output;     # httpd -v
my @apache_modules_output;     # httpd -M
my ( $phpversion, $php5version, $php4version, $php4handler, $php5handler, $suexec );

if ( -x '/usr/local/apache/bin/httpd' ) {
    @apache_version_output = split /\n/, timed_run( '/usr/local/apache/bin/httpd', '-v' );
    @apache_modules_output = split /\n/, timed_run( '/usr/local/apache/bin/httpd', '-M' );
}

######################
##  END GLOBALS     ##
######################


## [INFO]
print "\n";
check_for_dnsonly();
print_os();
print_kernel_and_cpu();
print_cpanel_info();
check_for_cpanel_update();
print_uptime();
check_for_clustering();
print_apache_info();
print_php_configuration();
check_sysinfo();
check_for_remote_mysql();
print_if_using_mydns_or_nsd();
print_if_using_modruid2();
print_which_php_is_used_internally();
print_mysql_version();

## [WARN]
check_for_nat();                            # NAT

check_for_unsupported_options_in_phpini(); # case 75397     # PHP

check_for_cloudlinux_mysql_gov();                   # CloudLinux        @rpm_list
check_for_nocloudlinux_touchfile();                 # CloudLinux        $is_cloudlinux
check_for_cloudlinux_not_licensed_through_cpanel(); # CloudLinux
check_for_lve_environment();                        # CloudLinux

check_for_cpanel_not_updating();            # Upcp

check_for_rpm_dist_ver_unknown();           # RPM

check_for_cdorked();                        # Hacked

check_for_cpbackup_exclude_everything();    # Cpbackup


check_for_libkeyutils_malware();

# This is run closer to the end since it has the potential to take the longest
build_rpm_list();

# These require build_rpm_list() to have been run, so that @rpm_list is populated
check_for_ebury_malware();
populate_mysql_rpm_versions_array();
check_for_mysql_4();
check_for_additional_rpms();
check_mysql_rpm_mismatch();
check_php_libmysqlclient_mismatch();
check_for_percona_rpms();
check_for_duplicate_rpms();
check_for_better_linux();

# All checks for DNSONLY go here
sub check_for_dnsonly {
    if ( -e '/var/cpanel/dnsonly' ) {

        print_version();
        print_start("\t\tDNSONLY: ");
        print_warning("/var/cpanel/dnsonly detected, assuming DNSONLY\n");

        ## [INFO]
        print_hostname();
        print_os();
        print_kernel_and_cpu();
        print_cpanel_info();
        check_for_cpanel_update();
        print_uptime();
        check_for_clustering();
        check_sysinfo();

        ## [WARN]
        check_selinux_status();
        check_runlevel();
        check_for_missing_root_cron();
        check_if_upcp_is_running();
        check_interface_lo();
        check_cpanelconfig_filetype();
        check_cpanelsync_exclude();
        check_for_lve_environment();
        check_perl_sanity();
        check_for_non_default_permissions();
        check_limitsconf();
        check_disk_space();
        check_disk_inodes();
        check_for_gdm();
        check_for_redhat_firewall();
        check_for_home_noexec();
        check_for_nat();
        check_for_oracle_linux();
        check_for_proc_mdstat_recovery();
        check_usr_local_cpanel_path_for_symlinks();
        check_for_system_mem_below_512M();
        check_for_options_rotate_redhat_centos_63();
        check_for_empty_yumconf();
        check_for_cpanel_files();
        check_bash_history_for_certain_commands();
        check_roots_cron_for_certain_commands();
        check_for_PERL5LIB_env_var();

        # check_for_cpsources_conf();       // does this exist on DNSONLY by default?
        check_cron_processes();
        check_etc_hosts_sanity();
        check_for_C_compiler_optimization();
        check_perl_version_less_than_588();
        check_for_fork_bomb_protection();
        check_for_cPanel_lower_than_11_30_7_3();
        check_for_non_default_umask();
        check_for_clock_skew();
        check_for_percona_rpms();
        check_for_duplicate_rpms();
        check_for_mainip_newline();
        check_for_rpm_overrides();
        check_var_cpanel_immutable_files();
        check_for_hordepass_newline();
        check_for_noxsave_in_grub_conf();
        check_for_cpanel_CN_newline();
        check_for_networkmanager();
        check_for_disabled_services();
        check_for_harmful_php_mode_600_cron();

        ## [3RDP]
        check_for_apf();
        check_for_csf();
        check_for_prm();
        check_for_les();
        check_for_1h();
        check_for_webmin();
        check_for_symantec();

        exit;
    }
}

sub get_cpanel_version {
    my $cpanel_version_file = '/usr/local/cpanel/version';

    if ( open my $file_fh, '<', $cpanel_version_file ) {
        while (<$file_fh>) {
            chomp( $cpanel_version = $_ );
        }
        close $file_fh;
    }

    if ( $cpanel_version =~ /(\d+\.\d+\.\d+\.\d+)/ ) {
        return $cpanel_version;
    }
    else {
        return 'unknown';
    }
}

# shameless rip of /usr/local/cpanel/Cpanel/SafeRun/Simple.pm which, along with
# all other current cPanel modules, is not guaranteed to work with 11.35+ apparently.
# so, we take what we need and put it here
sub run_trap_stderr {
    my $cmdline = \@_;
    my $output;

    local ($/);
    my ( $pid, $prog_fh );

    if ( $pid = open( $prog_fh, '-|' ) ) {

    }
    else {
        open STDERR, '>&STDOUT';
        ( $ENV{'PATH'} ) = $ENV{'PATH'} =~ m/(.*)/;    # untaint, FB 6622
        exec(@$cmdline);
        exit(127);
    }

    if ( !$prog_fh || !$pid ) {
        $? = -1;

        return \$output;
    }
    $output = readline($prog_fh);
    close($prog_fh);

    return $output;
}

# shameless rip of /usr/local/cpanel/Cpanel/SafeRun/Simple.pm which, along with
# all other current cPanel modules, is not guaranteed to work with 11.35+ apparently.
# so, we take what we need and put it here
sub run {
    my $cmdline = \@_;
    my $output;

    local ($/);
    my ( $pid, $prog_fh );

    if ( $pid = open( $prog_fh, '-|' ) ) {

    }
    else {
        open STDERR, '>', '/dev/null';
        ( $ENV{'PATH'} ) = $ENV{'PATH'} =~ m/(.*)/;    # untaint, FB 6622
        exec(@$cmdline);
        exit(127);
    }

    if ( !$prog_fh || !$pid ) {
        $? = -1;

        return \$output;
    }
    $output = readline($prog_fh);
    close($prog_fh);

    return $output;
}

sub timed_run {
    eval { local $SIG{__DIE__}; local $SIG{__WARN__}; require Cpanel::SafeRun::Timed; };

    if ( !$@ && $INC{'Cpanel/SafeRun/Timed.pm'} ) {
        open( my $save_stderr_fh, '>&STDERR' );
        open( STDERR, '>', '/dev/null' );
        my $result = Cpanel::SafeRun::Timed::timedsaferun( 10, @_ );
        open( STDERR, '>&=' . fileno($save_stderr_fh) );
        return $result;
    }
    goto \&run;
}

sub get_local_ipaddrs {
    my @ifconfig = split /\n/, run( 'ifconfig', '-a' );
    for my $line (@ifconfig) {
        if ( $line =~ m{ (\d+\.\d+\.\d+\.\d+) }xms ) {
            my $ipaddr = $1;
            unless ( $ipaddr =~ m{ \A 127\. }xms ) {
                push @local_ipaddrs_list, $ipaddr;
            }
        }
    }

    return @local_ipaddrs_list;
}

sub get_os {
    chomp( my $_os = lc run('uname') );
    return $_os;
}

# ripped from /usr/local/cpanel/Cpanel/Sys/OS.pm
sub get_release_version {
    my $ises = 0;
    my $ver;

    if ( open my $fh, '<', '/etc/redhat-release' ) {
        my $line = readline $fh;
        close $fh;
        chomp $line;
        if    ( $line =~ m/(?:Corporate|Advanced\sServer|Enterprise)/i ) { $ises = 1; }
        elsif ( $line =~ /CloudLinux|CentOS/i )                          { $ises = 2; }
        elsif ( $line =~ /WhiteBox/i )                                   { $ises = 3; }
        elsif ( $line =~ /caos/i )                                       { $ises = 4; }
        if    ( $line =~ /(\d+\.\d+)/ )                                  { $ver  = $1; }
        elsif ( $line =~ /(\d+)/ )                                       { $ver  = $1; }
    }

    if ( $os =~ /freebsd/i ) {
        if ( ( POSIX::uname() )[2] =~ m/^(\d+\.\d+)/ ) {
            $ver = $1;
        }
    }

    if ($ises) {
        return ( $ver, $ises );
    }
    else {
        return ( $ver, 0 );
    }
}

sub get_tiers_file {
    local $SIG{'ALRM'} = sub { return (); };
    alarm 5;

    my $sock = IO::Socket::INET->new(
        PeerAddr => 'httpupdate.cpanel.net',
        PeerPort => '80',
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /cpanelsync/TIERS HTTP/1.1\r\nHost: httpupdate.cpanel.net\r\n\r\n";
        sysread $sock, $TIERS, 1000;
        close $sock;
    }

    alarm 0;

    return $TIERS;
}

sub get_process_list {

    ## used for checking for nginx, litespeed, mailscanner, etc.
    ## better (?) would be to run lsof and check process names on listening ports.

    my @processlist;

    if ( $os eq 'linux' ) {
        @processlist = split /\n/, run( 'ps', 'axwwwf', '-o', 'user,cmd' );
    }
    elsif ( $os eq 'freebsd' ) {
        @processlist = split /\n/, run( 'ps', 'axwwwf', '-o', 'user,comm' );
    }

    return @processlist;
}

sub get_hostinfo {
    my %hostinfos;

    $hostinfos{'kernel'}   = run( 'uname', '-r' );
    $hostinfos{'hardware'} = run( 'uname', '-i' );
    $hostinfos{'environment'} = get_environment();

    chomp %hostinfos;
    return %hostinfos;
}

sub get_environment {
    if ( open my $envtype_fh, '<', '/var/cpanel/envtype' ) {
        my $envtype = readline($envtype_fh);
        close $envtype_fh;
        return $envtype;
    }
    else {
        return 'Unknown (could not open/read /var/cpanel/envtype ?)';
    }
}

sub get_cpuinfo {
    my %cpuinfos;

    if ( $os eq 'freebsd' ) {
        my $numcores = run( 'sysctl', 'hw.ncpu' );
        my $model    = run( 'sysctl', 'hw.model' );
        $numcores =~ s/^hw.ncpu://g;
        $model    =~ s/^hw.model://g;
        $model    =~ s/\s+/ /g;
        $cpuinfos{'numcores'} = $numcores;
        $cpuinfos{'model'}    = $model;
    }
    else {
        open my $cpuinfo_fh, '<', '/proc/cpuinfo';
        for my $line ( readline $cpuinfo_fh ) {
            if ( $line =~ /^model name/m ) {
                $line =~ s/^model name\s+:\s+//;
                $line =~ s/\(R\)//g;
                $line =~ s/\(tm\)//g;
                $line =~ s/\s{2,}/ /;
                $line =~ s/ \@/\@/;
                $cpuinfos{'model'} = $line;
                $cpuinfos{'numcores'}++;
            }
            if ( $line =~ /^cpu MHz/m ) {
                $line =~ s/^cpu MHz\s+:\s+//;
                $cpuinfos{'mhz'} = $line;
            }
        }
        close $cpuinfo_fh;
    }

    chomp %cpuinfos;
    return %cpuinfos;
}

sub print_info {
    my $text = shift;
    print BOLD YELLOW ON_BLACK "[INFO] * $text";
}

sub print_warn {
    my $text = shift;
    print BOLD RED ON_BLACK "[WARN] * $text";
}

sub print_3rdp {
    my $text = shift;
    print BOLD GREEN ON_BLACK "[3RDP] * $text";
}

sub print_3rdp2 {
    my $text = shift;
    print BOLD GREEN ON_BLACK "$text\n";
}

## precedes informational items (e.g., "Hostname:")
sub print_start {
    my $text = shift;
    print BOLD YELLOW ON_BLACK $text;
}
## for informational items (e.g., the server's hostname)
sub print_normal {
    my $text = shift;
    print BOLD CYAN ON_BLACK "$text\n";
}
## for important things (e.g., "Hostname is not a FQDN")
sub print_warning {
    my $text = shift;
    print BOLD RED ON_BLACK "$text\n";
}
## for other imporant things (e.g., "You are in an LVE, do not restart services")
sub print_warning_underline {
    my $text = shift;
    print BOLD UNDERLINE "$text\n";
}

sub print_info2 {
    my $text = shift;
    print BOLD GREEN ON_BLACK "$text\n";
}

sub print_magenta {
    my $text = shift;
    print BOLD MAGENTA ON_BLACK "$text\n";
}

##############################
#  BEGIN [INFO] CHECKS
##############################

sub print_os {
    my $release_info;
    my $os_info;
    my $php_selector_conf     = '/usr/local/cpanel/base/frontend/x3/dynamicui/dynamicui_lvephpsel.conf';
    my $php_selector_disabled = 0;

    if ( -e '/etc/redhat-release' ) {
        if ( open my $rr_fh, '<', '/etc/redhat-release' ) {
            while (<$rr_fh>) {
                chomp( $release_info = $_ );
            }
            close $rr_fh;
        }
        $os_info = $release_info . " [$hostinfo{'environment'}]";
    }
    elsif ( $os eq 'freebsd' ) {
        $os_info = 'FreeBSD';
    }
    else {
        $os_info = 'Unknown (no /etc/redhat-release, and not FreeBSD)';
    }

    if ( $release_info and $release_info =~ /cloudlinux/i ) {
        $is_cloudlinux = 1;
        if ( -f $php_selector_conf ) {
            if ( open my $file_fh, '<', $php_selector_conf ) {
                while (<$file_fh>) {
                    if (/^file=>lvephpsel,skipobj=>1/) {
                        $php_selector_disabled = 1;
                        last;
                    }
                }
                close $file_fh;
            }
        }
        else {
            $php_selector_disabled = 'status unknown';
        }
    }

    if ( $is_cloudlinux == 1 ) {
        if ( $php_selector_disabled eq 'status unknown' ) {
            $os_info .= ' [PHP Selector: status unknown]';
        }
        elsif ( $php_selector_disabled == 1 ) {
            $os_info .= ' [PHP Selector: disabled for x3]';
        }
        elsif ( $php_selector_disabled == 0 ) {
            $os_info .= ' [PHP Selector: enabled for x3]';
        }
    }

    print_info('OS: ');
    print_normal($os_info);
}

sub print_kernel_and_cpu {
    print_info('Kernel/CPU: ');
    print_normal("$hostinfo{'kernel'} $hostinfo{'hardware'} $hostinfo{'environment'} $cpuinfo{'model'} w/ $cpuinfo{'numcores'} core(s)");
}

sub print_cpanel_info {
    my $cpanel_tier;
    my ( $birthday_file, $birthday );
    my $output;

    ## cpanel-install-thread0.log is better to be checked before cpanel-install.log
    if ( -f '/var/log/cpanel-install-thread0.log' ) {
        $birthday_file = '/var/log/cpanel-install-thread0.log';
    }
    elsif ( -f '/var/log/cpanel-install.log' ) {
        $birthday_file = '/var/log/cpanel-install.log';
    }

    if ($birthday_file) {
        my $ctime = ( stat($birthday_file) )[9];
        $birthday = localtime $ctime;
    }

    if ( open my $cpupdate_fh, '<', '/etc/cpupdate.conf' ) {
        while (<$cpupdate_fh>) {
            if (m{ \A CPANEL=(.*) }xmsi) {
                chomp( $cpanel_tier = $1 );
            }
        }
        close $cpupdate_fh;
    }
    else {
        $cpanel_tier = 'Unknown (could not open/read /etc/cpupdate.conf ?)';
    }

    my $ctime       = ( stat('/usr/local/cpanel/version') )[10];
    my $last_update = time() - $ctime;
    $last_update = $last_update / 86400;
    $last_update = sprintf '%.1f', $last_update;

    if ($birthday) {
        $output = "${cpanel_version} " . '(' . uc($cpanel_tier) . ' tier)' . " Last update: $last_update days ago" . " [ Installed $birthday ]";
    }
    else {
        $output = "${cpanel_version} " . '(' . uc($cpanel_tier) . ' tier)' . " Last update: $last_update days ago";
    }

    print_info('cPanel Info: ');
    print_normal($output);
}

sub check_for_cpanel_update {
    my ( $TIERS_DATA, @tiers );
    my ( $tier,       $available_tier_version );
    my $local_tier_name;
    my $local_tier_version = $cpanel_version;
    my $match              = 0;
    my $update_available   = 0;

    #
    # get local tier name (e.g., edge)
    #
    my $cpupdate_conf = '/etc/cpupdate.conf';
    return if !$cpupdate_conf;

    if ( open my $file_fh, '<', $cpupdate_conf ) {
        while (<$file_fh>) {
            if (/\bcpanel=(.*)/i) {
                $local_tier_name = $1;
                last;
            }
        }
        close $file_fh;
    }

    return if !$local_tier_name;

    #
    # get local tier version (e.g., 11.36.0.4)
    #
    if ( $local_tier_version !~ /(\d+\.\d+\.\d+\.\d+)/ ) {
        print_info('cPanel update check: ');
        print_warning("unknown or old cPanel version $local_tier_version");
        return;
    }

    #
    # get available tiers and versions (e.g., edge:11.36.0.4)
    #
    local $SIG{'ALRM'} = sub { return (); };

    alarm 5;

    my $sock = IO::Socket::INET->new(
        PeerAddr => 'httpupdate.cpanel.net',
        PeerPort => 80,
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /cpanelsync/TIERS HTTP/1.1\r\nHost: httpupdate.cpanel.net\r\n\r\n";
        sysread $sock, $TIERS_DATA, 1000;
        close $sock;
    }

    alarm 0;

    return if !$TIERS_DATA;

    @tiers = split /\n/, $TIERS_DATA;

    #
    # does the local server use a recognized tier?
    #
    for my $line (@tiers) {
        if ( $line =~ m{ \A (.*) : (\d+\.\d+\.\d+\.\d+) \z }xms ) {
            ( $tier, $available_tier_version ) = ( $1, $2 );
            if ( $tier eq $local_tier_name ) {
                $match = 1;
                last;
            }
        }
    }

    if ( $match == 0 ) {
        print_info('cPanel update check: ');
        print_warning("server is configured to use an unknown tier ($local_tier_name)");
        return;
    }

    #
    # does the local tier version match the available tier version?
    #
    return if ( $local_tier_version eq $available_tier_version );

    #
    # FreeBSD won't ever go past 11.30
    # http://www.cpanel.net/products/cpanelwhm/system-requirements.html
    #
    return if ( ( $os eq 'freebsd' ) && substr( $local_tier_version, 0, 5 ) eq '11.30' );

    my ( $l1, $l2, $l3, $l4 ) = split /\./, $local_tier_version;
    my ( $r1, $r2, $r3, $r4 ) = split /\./, $available_tier_version;

    if ( $l1 < $r1 ) {
        $update_available = 1;
    }
    elsif ( ( $l1 == $r1 ) and ( $l2 < $r2 ) ) {
        $update_available = 1;
    }
    elsif ( ( $l1 == $r1 ) and ( $l2 == $r2 ) and ( $l3 < $r3 ) ) {
        $update_available = 1;
    }
    elsif ( ( $l1 == $r1 ) and ( $l2 == $r2 ) and ( $l3 == $r3 ) and ( $l4 < $r4 ) ) {
        $update_available = 1;
    }

    if ( $update_available == 1 ) {
        print_info('cPanel update check: ');
        print_warning("UPDATE AVAILABLE ($local_tier_version -> $available_tier_version)");
    }
}

sub print_uptime {
    chomp( my $uptime = run('uptime') );
    print_info('Uptime: ');
    print_normal($uptime);
}

sub check_for_clustering {
    if ( -e '/var/cpanel/useclusteringdns' ) {
        print_info('DNS Clustering: ');
        print_normal('is enabled');
    }
    else {
        return;
    }

    my $cluster_dir = '/var/cpanel/cluster/root/config';
    my @dir_contents;
    my @cluster_members;
    my ( $cluster_member_ipaddr, $cluster_member_hostname, $cluster_member_role );

    if ( -d $cluster_dir ) {
        opendir( my $dir_fh, $cluster_dir );
        @dir_contents = grep { !/^\.(\.?)$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    chdir $cluster_dir or return;

    for my $dirent (@dir_contents) {

        # only active cluster members have -dnsrole files
        if ( $dirent =~ m{ \A (\d+\.\d+\.\d+\.\d+)-dnsrole \z }xms ) {
            $cluster_member_ipaddr = $1;

            if ( open my $file_fh, '<', "${cluster_member_ipaddr}.cache" ) {
                my $cache_ref;
                eval 'local $SIG{__DIE__}; local $SIG{__WARN__}; $cache_ref = Storable::fd_retrieve($file_fh);';    # from upcp.static
                close $file_fh;
                if ($cache_ref) {
                    $cluster_member_hostname = $cache_ref->{'host'};
                }
                close $file_fh;
            }
            else {
                $cluster_member_hostname = '?';
            }

            if ( !$cluster_member_hostname ) {
                $cluster_member_hostname = '?';
            }

            if ( open my $file_fh, '<', "${cluster_member_ipaddr}-dnsrole" ) {
                while (<$file_fh>) {
                    $cluster_member_role = $_;
                }
                close $file_fh;
            }
            else {
                $cluster_member_role = '?';
            }

            push @cluster_members, $cluster_member_hostname . '_SSP_' . $cluster_member_ipaddr . '_SSP_' . "[${cluster_member_role}]";
        }
    }

    ## print sorted output for cluster members, by hostname
    if (@cluster_members) {
        @cluster_members = sort @cluster_members;

        for my $member (@cluster_members) {
            $member =~ s/_SSP_/ /g;
            print_magenta("\t \\_ $member");
        }
    }
}

sub print_apache_info {
    my $output;
    my $apache_status;

    if (@apache_version_output) {    # httpd -v

        my ( $apache_version, $apache_built, $apache_ea_version );

        for my $line (@apache_version_output) {
            if ( $line =~ m{ \A Server \s version: \s (.*) \z }xms ) {
                $apache_version = $1;
            }
            if ( $line =~ m{ \A Server \s built: \s (.*) \z }xms ) {
                $apache_built = $1;
                $apache_built =~ s/^\s+//g;
            }
            if ( $line =~ m{ \A Cpanel::Easy::Apache \s (.*) \z }xms ) {
                $apache_ea_version = $1;
            }
        }

        if ( !$apache_version or !$apache_built or !$apache_ea_version ) {
            $output .= 'could not determine Apache info!';
        }
        else {
            $output .= "[ $apache_version ] [ $apache_built w/ $apache_ea_version ]";
        }
    }

    my ( $apache_uptime, $apache_generations );

    local $SIG{'ALRM'} = sub { };
    alarm 5;

    my $sock = IO::Socket::INET->new(
        PeerAddr => '127.0.0.1',
        PeerPort => 80,
        Proto    => 'tcp',
        Timeout  => 3,
    );

    if ($sock) {
        print $sock "GET /whm-server-status HTTP/1.0\r\n\r\n";
        sysread $sock, $apache_status, 10_000;
        close $sock;
    }

    alarm 0;

    if ($apache_status) {
        my @apache_status = split /\n/, $apache_status;

        for my $line (@apache_status) {
            if ( $line =~ m{ Server \s uptime: \s+ (.*) </dt> }xms ) {
                $apache_uptime = $1;
                $apache_uptime = 'Up ' . $apache_uptime;
            }
            if ( $line =~ m{ Parent \s Server \s Generation: (.*) </dt> }xms ) {
                $apache_generations = $1;
            }
        }
        if ( $apache_uptime and $apache_generations ) {
            $output .= " [ $apache_uptime w/ $apache_generations generation(s) ]";
        }
    }
    else {
        my $warning = 'Apache is not up (failed: http://localhost/whm-server-status). ';

        if ( $os eq 'linux' ) {
            my @lsof_80 = split /\n/, run( 'lsof', '-n', '-i', 'tcp:80' );
            if (@lsof_80) {
                $warning .= 'Something is listening on port 80.';
            }
            else {
                $warning .= 'Nothing is listening on port 80';
            }
        }

        print_info('Apache: ');
        print_warning($warning);
        return;
    }

    if ($output) {
        print_info('Apache: ');
        print_normal($output);
    }

}

sub print_php_configuration {
    my $phpconf = '/usr/local/apache/conf/php.conf.yaml';
    return if !-f $phpconf;

    open my $phpconf_fh, '<', $phpconf;
    while (<$phpconf_fh>) {
        chomp;
        if (/^phpversion: (\d)/) {
            $phpversion = $1;
        }
        if (/^php4:[ \t]+['"]?([^'"]+)/) {
            $php4handler = $1;
        }
        if (/^php5:[ \t]+['"]?([^'"]+)/) {
            $php5handler = $1;
        }
        if (/^suexec:[ \t]+['"]?([^'"]+)/) {
            $suexec = $1;
        }
    }
    close $phpconf_fh;

    if ( $suexec && $suexec == 1 ) {
        $suexec = '/w suexec';
    }
    else {
        $suexec = 'without suexec';
    }

    if ( $phpversion == 5 ) {
        if ( -x '/usr/bin/php' ) {
            my @php_v = split /\n/, cached_run( '/usr/bin/php', '-v' );
            if ( $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $php5version = $1;
            }
            else {
                $php5version = '(version unknown)';
            }

            if ( $php5handler eq 'fcgi' ) {
                print_info('PHP Default: ');
                print_warning("PHP $php5version $php5handler $suexec (mod_userdir style URLs don't work with fcgi!)");
            }
            else {
                print_info('PHP Default: ');
                print_normal("PHP $php5version $php5handler $suexec");
            }
        }

        if ( $php4handler ne 'none' ) {
            my @php_v = split /\n/, cached_run( '/usr/local/php4/bin/php', '-v' );
            if ( @php_v && $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $php4version = $1;
            }
            else {
                $php4version = '(version unknown)';
            }

            print_info('PHP Secondary: ');
            print_normal("PHP $php4version $php4handler $suexec");
        }
    }

    if ( $phpversion == 4 ) {
        if ( -x '/usr/local/php4/bin/php' ) {
            my @php_v = split /\n/, cached_run( '/usr/local/php4/bin/php', '-v' );
            if ( $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $php4version = $1;
            }
            else {
                $php4version = '(version unknown)';
            }

            if ( $php4handler eq 'fcgi' ) {
                print_info('PHP Default: ');
                print_warning("PHP $php4version $php4handler $suexec (mod_userdir style URLs don't work with fcgi!)");
            }
            else {
                print_info('PHP Default: ');
                print_normal("PHP $php4version $php4handler $suexec");
            }
        }

        if ( $php5handler ne 'none' ) {
            my @php_v = split /\n/, cached_run( '/usr/bin/php', '-v' );
            if ( $php_v[0] =~ /^PHP\s(\S+)\s(\S+)/ ) {
                $php5version = $1;
            }
            else {
                $php5version = '(version unknown)';
            }

            print_info('PHP Secondary: ');
            print_normal("PHP $php5version $php5handler $suexec");
        }
    }

    if ( $php4handler eq 'none' and $php5handler eq 'none' ) {
        print "\n";
        print_warn('PHP: ');
        print_warning('no handler defined for PHP4 or PHP5!');
    }
}

sub check_sysinfo {
    return if !-x '/scripts/gensysinfo';

    my $sysinfo_config = '/var/cpanel/sysinfo.config';

    my ( $release, $ises ) = get_release_version();    # 5.8, 2
    chomp( my $arch = run( 'uname', '-i' ) );

    my $rebuild = 0;

    if ( !-e $sysinfo_config ) {
        print_info('sysinfo: ');
        print_warning('does not exist, running /scripts/gensysinfo to fix');
        run('/scripts/gensysinfo');
    }
    else {
        open my $sysinfo_fh, '<', $sysinfo_config;
        while (<$sysinfo_fh>) {
            chomp;
            if (m{ \A rpm_arch=(.*) }xms) {
                if ( $os eq 'freebsd' ) {
                    $rebuild = 0;
                }
                elsif ( $arch ne $1 ) {
                    $rebuild = 1;
                }
            }
            if (m{ \A release=(.*) }xms) {
                if ( $release ne $1 ) {
                    $rebuild = 1;
                }
            }
            if (m{ \A ises=(.*) }xms) {
                if ( $ises ne $1 ) {
                    $rebuild = 1;
                }
            }
        }
        close $sysinfo_fh;
    }

    if ( $rebuild == 1 ) {
        run( 'mv', $sysinfo_config, "${sysinfo_config}.ssp.$^T" );
        run('/scripts/gensysinfo');
        print_info('sysinfo: ');
        print_warning('/var/cpanel/sysinfo.config contained errors and was rebuilt');
    }
}

sub check_for_remote_mysql {
    my $mysql_host;
    my $mysql_is_local;

    ## obtain mysql host, if exists
    my $my_cnf = '/root/.my.cnf';
    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A host \s* = \s* (?:["']?) ([^"']+) }xms ) {
                $mysql_host = $1;
            }
        }
        close $my_cnf;
    }

    if ($mysql_host) {
        if ( $mysql_host =~ m{ ( \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} )  }xms ) {
            return if ( $mysql_host eq '127.0.0.1' );
            for my $ipaddr (@local_ipaddrs_list) {
                if ( $ipaddr eq $mysql_host ) {
                    $mysql_is_local = 1;
                    last;
                }
            }
        }
        elsif ( $mysql_host eq 'localhost' or $mysql_host eq hostname() ) {
            $mysql_is_local = 1;
        }
        if ( !$mysql_is_local ) {
            print_info('Remote MySQL Host: ');
            print_warning($mysql_host);
        }
    }
}

sub print_if_using_mydns_or_nsd {
    if ( -e '/var/cpanel/usensd' ) {
        print_info('DNS Service: ');
        print_normal('NSD ');
    }
    elsif ( -e '/var/cpanel/usemydns' ) {
        print_info('DNS Service: ');
        print_normal('MyDNS ');
    }
}

sub print_if_using_modruid2 {
    for (@apache_modules_output) {
        if (/ruid2_module/) {
            print_info('mod_ruid2: ');
            print_normal('is enabled');
            last;
        }
    }
}

sub print_which_php_is_used_internally {
    my ( $v1, $v2 ) = split /\./, $cpanel_version;

    # /var/cpanel/usecpphp is no longer used in cPanel 11.36+
    if ( ( $v1 > 11 ) || ( $v1 == 11 ) and ( $v2 >= 36 ) ) {
        return;
    }

    # http://docs.cpanel.net/twiki/bin/view/AllDocumentation/WHMDocs/CpsrvdAndPhp

    my $whm_php;
    my $cpanel_php;

    # WHM, Webmail, phpMyAdmin, phpPgAdmin
    if ( -f '/var/cpanel/usecpphp' ) {
        if ( -x '/var/cpanel/3rdparty/bin/php-cgi' ) {
            $whm_php = '/var/cpanel/3rdparty/bin/php-cgi';
        }
        else {
            if ( -x '/var/cpanel/3rdparty/bin/php' ) {
                $whm_php = '/var/cpanel/3rdparty/bin/php';
            }
            else {
                if ( -x '/usr/local/cpanel/3rdparty/bin/php-cgi' ) {
                    $whm_php = '/usr/local/cpanel/3rdparty/bin/php-cgi';
                }
                else {
                    $whm_php = '/usr/local/cpanel/3rdparty/bin/php';
                }
            }
        }
    }
    else {
        if ( -x '/usr/local/cpanel/3rdparty/bin/php-cgi' ) {
            $whm_php = '/usr/local/cpanel/3rdparty/bin/php-cgi';
        }
        else {
            $whm_php = '/usr/local/cpanel/3rdparty/bin/php';
        }
    }

    # cPanel
    if ( -f '/var/cpanel/usecpphp' ) {
        $cpanel_php = $whm_php;
    }
    else {
        if ( -x '/usr/bin/php-cgi' ) {
            $cpanel_php = '/usr/bin/php-cgi';
        }
        else {
            $cpanel_php = '/usr/bin/php';
        }
    }

    if ( $whm_php eq $cpanel_php ) {
        print_info('Internal PHP: ');
        print_normal("$whm_php (used by WHM, cPanel, webmail, phpMyAdmin, phpPgAdmin)");
    }
    else {
        print_info('Internal PHP: ');
        print_normal("$whm_php (used by WHM, webmail, phpMyAdmin, phpPgAdmin) $cpanel_php (used by cPanel)");
    }
}

sub print_mysql_version {
    my $mysql_output = run( 'mysql', '-V' );
    if ( $mysql_output ) {
        chomp $mysql_output;
        print_info('MySQL Version: ');
        print_normal($mysql_output);
    }
}

##############################
#  END [INFO] CHECKS
##############################

##############################
#  BEGIN [WARN] CHECKS
##############################

sub check_for_lve_environment {

    # pam_lve 0.2 prints this after su or sudo:
    #
    # # /bin/su -
    # Password:
    # ***************************************************************************
    # *                                                                         *
    # *             !!!!  WARNING: YOU ARE INSIDE LVE !!!!                      *
    # *IF YOU RESTART ANY SERVICES STABILITY OF YOUR SYSTEM WILL BE COMPROMIZED *
    # *        CHANGE UID OF THE USER YOU ARE USING TO SU/SUDO                  *
    # *                             MORE INFO:                                  *
    # *http://www.cloudlinux.com/blog/clnews/read-this-if-you-use-su-or-sudo.php*
    # *                                                                         *
    # ***************************************************************************

    # pam_lve 0.3 won't put wheel users in an LVE after su or sudo:
    # http://cloudlinux.com/blog/clnews/read-this-if-you-use-su-or-sudo.php

    if ( $hostinfo{'kernel'} =~ /\.lve/ and -x '/usr/sbin/lveps' ) {
        my $lve_check = `/usr/sbin/lveps -p | grep " $$ "`;
        if ($lve_check) {
            print "\n";
            print_warning_underline(' !! YOU ARE IN AN LVE - DO *NOT* RESTART ANY SERVICES !!');
            print_warning_underline(' !! YOU ARE IN AN LVE - DO *NOT* RESTART ANY SERVICES !!');
            print_warning_underline(' !! YOU ARE IN AN LVE - DO *NOT* RESTART ANY SERVICES !!');
            print "\n";
        }
    }
}

sub check_perl_sanity {
    my $usr_bin_perl       = '/usr/bin/perl';
    my $usr_local_bin_perl = '/usr/local/bin/perl';

    if ( !$usr_bin_perl ) {
        print_warn('perl: ');
        print_warning("$usr_bin_perl does not exist!");
    }
    if ( !$usr_local_bin_perl ) {
        print_warn('perl: ');
        print_warning("$usr_local_bin_perl does not exist!");
    }

    if ( -l $usr_bin_perl and -l $usr_local_bin_perl ) {
        my $usr_bin_perl_link       = readlink $usr_bin_perl;
        my $usr_local_bin_perl_link = readlink $usr_local_bin_perl;
        if ( -l $usr_bin_perl_link and -l $usr_local_bin_perl_link ) {
            print_warn('perl: ');
            print_warning("$usr_bin_perl and $usr_local_bin_perl are both symlinks!");
        }
    }

    ## a symlink will test true for both -x AND -l
    if ( -x $usr_bin_perl and !-l $usr_bin_perl ) {
        if ( -x $usr_local_bin_perl and !-l $usr_local_bin_perl ) {
            print_warn('perl: ');
            print_warning("$usr_bin_perl and $usr_local_bin_perl are both binaries!");
        }
    }

    if ( -x $usr_bin_perl and !-l $usr_bin_perl ) {
        my $mode = ( stat($usr_bin_perl) )[2] & 07777;
        $mode = sprintf "%lo", $mode;
        if ( $mode != 755 ) {
            print_warn('Perl Permissions: ');
            print_warning("$usr_bin_perl is $mode");
        }
    }

    if ( -x $usr_local_bin_perl and !-l $usr_local_bin_perl ) {
        my $mode = ( stat($usr_local_bin_perl) )[2] & 07777;
        $mode = sprintf "%lo", $mode;
        if ( $mode != 755 ) {
            print_warn('Perl Permissions: ');
            print_warning("$usr_local_bin_perl is $mode");
        }
    }
}

## compare external IP addr with local IP addrs, OR
## check if only internal IP addrs are bound to server (this is not as reliable,
## as NAT can still be used with external IP addrs of course)
sub check_for_nat {
    return if -e '/var/cpanel/cpnat';

    my @external_ipaddrs;
    my $reply;
    my $count = 0;

    for ( 1 .. 3 ) {
        local $SIG{'ALRM'} = sub {
            $count++;
            print_warn('NAT check timed out: ');
            print_warning("attempt $count of 3");
        };
        alarm 3;

        my $sock = IO::Socket::INET->new(
            PeerAddr => 'cpanel.net',
            PeerPort => '80',
            Proto    => 'tcp',
            Timeout  => 3,
        );

        if ($sock) {
            print $sock "GET /showip.cgi HTTP/1.0\r\n\r\n";
            sysread $sock, $reply, 1000;
            close $sock;
        }

        if ( $reply and $reply =~ m{ (\d+\.\d+\.\d+\.\d+) }xms ) {
            $external_ip_address = $1;
        }
        else {
            return;
        }

        if ($external_ip_address) {
            chomp $external_ip_address;
        }
        alarm 0;

        if ($external_ip_address) {
            last;
        }
    }

    if ( $external_ip_address && $external_ip_address =~ m{ \A \d+\.\d+\.\d+\.\d+ }xms ) {
        if ( !grep { /$external_ip_address/ } @local_ipaddrs_list ) {
            print_warn('NAT: ');
            print_warning("external IP address $external_ip_address is not bound to server");
        }
    }
    else {
        for my $ipaddr (@local_ipaddrs_list) {
            if ( $ipaddr !~ m{ \A ( ?: 127\. | 192\.168\. | 10\. | 172\.(1[6-9]|2[0-9]|3[0-1]) ) }xms ) {
                push @external_ipaddrs, $ipaddr;
            }
        }
        if ( !@external_ipaddrs ) {
            print_warn('NAT: ');
            print_warning('no external IP addresses detected');
        }
    }
}

sub find_usr_local_cpanel_hooks {
    my $file = $File::Find::name;
    if ( -f $file and $file !~ m{ ( README | \.example ) \z }xms ) {
        $file =~ s#/usr/local/cpanel/hooks/##;
        push @usr_local_cpanel_hooks, $file;
    }
}

sub get_mysql_datadir {
    my $my_cnf  = '/etc/my.cnf';
    my $datadir = '/var/lib/mysql/';

    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A datadir \s* = \s* (?:["']?) ([^"']+) }xms ) {
                $datadir = $1;
                $datadir =~ s/[\s\t]+$//g;
                last;
            }
        }
        close $my_cnf_fh;
    }

    if ( $datadir !~ m{ / \z }xms ) {
        $datadir .= '/';
    }

    return $datadir;
}

sub populate_mysql_rpm_versions_array {
    return if !@rpm_list;

    for my $rpm (@rpm_list) {
        if ( $rpm =~ m{ \A MySQL-server-(.*) \z }xms ) {
            push @mysql_rpm_versions, $1;
        }
        elsif ( $rpm =~ m{ \A MySQL-shared-(.*) \z }xms ) {
            push @mysql_rpm_versions, $1;
        }
        elsif ( $rpm =~ m{ \A MySQL-devel-(.*) \z }xms ) {
            push @mysql_rpm_versions, $1;
        }
        elsif ( $rpm =~ m{ \A MySQL-client-(.*) \z }xms ) {
            push @mysql_rpm_versions, $1;
        }
        elsif ( $rpm =~ m{ \A MySQL-test-(.*) \z }xms ) {
            push @mysql_rpm_versions, $1;
        }
        elsif ( $rpm =~ m{ \A MySQL-embedded-(.*) \z }xms ) {
            push @mysql_rpm_versions, $1;
        }
    }
}

sub check_for_mysql_4 {
    return if !@mysql_rpm_versions;

    my $mysql_4 = 0;

    for my $rpm (@mysql_rpm_versions) {
        if ( $rpm =~ m{ \A 4 }xms ) {
            $mysql_4 = 1;
            last;
        }
    }

    if ( $mysql_4 == 1 ) {
        print_warn('MySQL 4.x RPM: ');
        print_warning('found! This can interfere with cPanel updates');
    }
}

sub check_for_additional_rpms {
    return if !@rpm_list;

    my @additional_rpms = grep { /^(php-|kde-|psa-|clamav|clamd|rrdtool-)|(http|apache|pear|sendmail)/ } @rpm_list;
    if (@additional_rpms) {
        @additional_rpms = sort @additional_rpms;
        for my $additional_rpm (@additional_rpms) {
            next if ( $additional_rpm =~ /httpd-tools|cpanel-|alt-php/ );
            print_start('Additional RPM: ');
            print_warning($additional_rpm);
        }
    }
}

sub check_mysql_rpm_mismatch {
    return if !@rpm_list;

    my $first_rpm = pop @mysql_rpm_versions;
    for ( 1 .. scalar @mysql_rpm_versions ) {
        my $next_rpm = pop @mysql_rpm_versions;
        if ( $first_rpm ne $next_rpm ) {
            print_warn('MySQL RPMs: ');
            print_warning('version mismatch!');
            last;
        }
    }
}

sub check_php_libmysqlclient_mismatch {
    return if !@rpm_list;

    my ( @php4_ldd,                    @php5_ldd );
    my ( $php4_libmysqlclient_version, $php5_libmysqlclient_version );

    my $php4_binary = '/usr/local/php4/bin/php';
    my $php5_binary = '/usr/bin/php';

    my $php4_mismatch = 0;
    my $php5_mismatch = 0;

    my $mysql_shared_rpm_version_orig;
    my $mysql_shared_rpm_version;

    ## Get the MySQL-shared rpm major and minor version.
    for my $rpm (@rpm_list) {
        if ( $rpm =~ /MySQL-shared-(\d)\.(\d)/ ) {
            $mysql_shared_rpm_version_orig = $rpm;
            $mysql_shared_rpm_version      = $1 . $2;
            last;
        }
    }

    return if !$mysql_shared_rpm_version;

    ## Run ldd against whichever major php version is active
    if ( open my $phpconfyaml_fh, '<', '/usr/local/apache/conf/php.conf.yaml' ) {
        while ( my $line = <$phpconfyaml_fh> ) {
            if ( $line =~ m{ \A php4: \s (.*) }xms ) {
                if ( $1 ne 'none' ) {
                    @php4_ldd = split /\n/, run( 'ldd', $php4_binary );
                }
            }
            elsif ( $line =~ m{ \A php5: \s (.*) }xms ) {
                if ( $1 ne 'none' ) {
                    @php5_ldd = split /\n/, run( 'ldd', $php5_binary );
                }
            }
        }
        close $phpconfyaml_fh;
    }

    ## Get the linked libmysqlclient version
    if (@php4_ldd) {
        for my $libs (@php4_ldd) {
            if ( $libs =~ m{ \A \s+ libmysqlclient\.so\.(\d+) \s => \s (?:\S+) \s (?:\S+) \z }xms ) {
                $php4_libmysqlclient_version = $1;
                last;
            }
        }
    }

    if (@php5_ldd) {
        for my $libs (@php5_ldd) {
            if ( $libs =~ m{ \A \s+ libmysqlclient\.so\.(\d+) \s => \s (?:\S+) \s (?:\S+) \z }xms ) {
                $php5_libmysqlclient_version = $1;
                last;
            }
        }
    }

    ## Compare the linked libmysqlclient lib with the MySQL-shared rpm version
    ##
    ## libmysqlclient.so.18 = MySQL-shared 5.5
    ## libmysqlclient.so.16 = MySQL-shared 5.1
    ## libmysqlclient.so.15 = MySQL-shared 5.0

    if ($php4_libmysqlclient_version) {
        if ( $php4_libmysqlclient_version == 18 and $mysql_shared_rpm_version != 55 ) {
            $php4_mismatch = 1;
        }
        elsif ( $php4_libmysqlclient_version == 16 and $mysql_shared_rpm_version != 51 ) {
            $php4_mismatch = 1;
        }
        elsif ( $php4_libmysqlclient_version == 15 and $mysql_shared_rpm_version != 50 ) {
            $php4_mismatch = 1;
        }

        if ( $php4_mismatch == 1 ) {
            print_warn('PHP/libmysqlclient mismatch: ');
            print_warning("$php4_binary linked against libmysqlclient.so.$php4_libmysqlclient_version, but MySQL-shared rpm is $mysql_shared_rpm_version_orig");
        }
    }

    if ($php5_libmysqlclient_version) {
        if ( $php5_libmysqlclient_version == 18 and $mysql_shared_rpm_version != 55 ) {
            $php5_mismatch = 1;
        }
        elsif ( $php5_libmysqlclient_version == 16 and $mysql_shared_rpm_version != 51 ) {
            $php5_mismatch = 1;
        }
        elsif ( $php5_libmysqlclient_version == 15 and $mysql_shared_rpm_version != 50 ) {
            $php5_mismatch = 1;
        }

        if ( $php5_mismatch == 1 ) {
            print_warn('PHP/libmysqlclient mismatch: ');
            print_warning("$php5_binary linked against libmysqlclient.so.$php5_libmysqlclient_version, but MySQL-shared rpm is $mysql_shared_rpm_version_orig");
        }
    }
}

# ripped some of Cpanel::Sys::GetOS::getos() for this
sub check_for_cpanel_not_updating {
    my ( $v1, $v2 ) = split /\./, $cpanel_version;
    my $os_vendor;
    my $release_string;
    my $updates;
    my @release_files = qw(
      fedora-release
      whitebox-release
      trustix-release
      caos-release
      gentoo-release
      SuSE-release
      mandrake-release
      CentOS-release
      redhat-release
      debian_version
    );

    if ( $^O =~ /freebsd/i ) {
        $os_vendor = 'freebsd';
    }
    else {
        for my $release_file (@release_files) {
            if ( -e '/etc/' . $release_file ) {
                if ( ( ($os_vendor) = $release_file =~ m/^([^\-_]+)/ )[0] ) {
                    $os_vendor = lc $os_vendor;
                    last;
                }
            }
        }
    }

    ## Ignore FBSD, Fedora, RHEL 3-4, Redhat 7-9
    return if ( $os_vendor =~ /(freebsd|fedora)/ );

    if ( -f '/etc/redhat-release' ) {
        if ( open my $rr_fh, '<', '/etc/redhat-release' ) {
            $release_string = readline $rr_fh;
            close $rr_fh;
        }
        else {
            $release_string = 'unknown';
        }
    }

    return if ( $release_string =~ /Red Hat Enterprise Linux (?:.*) release (3|4)/ );
    return if ( $release_string =~ /Red Hat Linux release ([7-9])/ );

    if ( open my $cpupdate_conf_fh, '<', '/etc/cpupdate.conf' ) {
        while (<$cpupdate_conf_fh>) {
            if (/UPDATES=(.*)/) {
                $updates = lc $1;
                last;
            }
        }
        close $cpupdate_conf_fh;
    }

    $updates = 'unknown' if !$updates;

    ## TEST 1: cPanel < 11.29, updates set to daily
    if ( ( $v1 < 11 ) || ( $v1 == 11 ) and ( $v2 < 29 ) ) {
        if ( $updates eq 'daily' ) {
            print "\n!! cPanel may not be updating on this server !!\n";
            print_warn('L1/L2: ');
            print_warning('escalate the ticket to L3 now');
            print_warn('L3: ');
            print_warning('check cP updatelogs, see why cPanel isn\'t updated, try to update if needed. Escalate to L4 if it can\'t update');
            print "\n\n";
        }
    }
    ## TEST 2: cPanel >= 11.29, updates set to daily, not updated in >= 24 hours
    ## Check removed for now due to false positives
}

sub get_mysql_error_log {
    if ( open my $file_fh, '<', '/etc/my.cnf' ) {
        while (<$file_fh>) {
            if (m{ \A log-error \s? = \s? (.*) \z }xms) {
                $mysql_error_log = $1;
                $mysql_error_log =~ s/\"//g;
                $mysql_error_log =~ s/\'//g;
                chomp $mysql_error_log;
                last;
            }
        }
        close $file_fh;
    }

    if ($mysql_error_log) {
        return $mysql_error_log;
    }
    else {
        return '/var/lib/mysql/' . $hostname . '.err';
    }
}

sub check_for_better_linux {
    return if !@extended_rpm_list;

    foreach my $rpm_ref ( grep { $_->{'name'} =~ m/^kernel/ } @extended_rpm_list ) {
        if ( $rpm_ref->{'release'} =~ m/\.bl/ ) {
            print_warn("BetterLinux detected:\n");
            print_magenta("\t \\_ Branding problems? See FB 64368");
            print_magenta("\t \\_ ImageMagick segfaulting? See tickets 4185629, 4087003");
            last;
        }
    }
}

sub check_for_duplicate_rpms {
    return if !@extended_rpm_list;

    my %SEEN_RPMS;
    my %DUP_RPMS;
    foreach my $rpm_ref (@extended_rpm_list) {
        push @{ $SEEN_RPMS{ $rpm_ref->{'name'} . '-' . $rpm_ref->{'arch'} } }, $rpm_ref->{'version'} . '-' . $rpm_ref->{'release'};
        if ( scalar @{ $SEEN_RPMS{ $rpm_ref->{'name'} . '-' . $rpm_ref->{'arch'} } } > 1 ) {
            $DUP_RPMS{ $rpm_ref->{'name'} . '-' . $rpm_ref->{'arch'} } = 1;
        }

    }

    foreach my $dup_rpm ( sort keys %DUP_RPMS ) {
        next if ( $dup_rpm =~ m{^(?:gpg-pubkey|kernel)} );

        print_warn('DUPLICATE RPM: ');
        print_warning( "$dup_rpm has multiple version: " . join( " ", @{ $SEEN_RPMS{$dup_rpm} } ) );

    }
}

sub check_for_percona_rpms {
    return if !@rpm_list;

    my $has_percona = 0;

    for my $rpm (@rpm_list) {
        if ( $rpm =~ /^Percona-/i ) {
            $has_percona = 1;
            last;
        }
    }

    if ( $has_percona == 1 ) {
        print_warn('Percona: ');
        print_warning('rpms found. If Exim is segfaulting after STARTTLS, this may be why. See ticket 3658929');
    }
}

sub check_if_httpdconf_ipaddrs_exist {
    my $httpdconf = '/usr/local/apache/conf/httpd.conf';
    my @vhost_ipaddrs;
    my @unbound_ipaddrs;

    return if !$httpdconf;

    if ( open my $httpdconf_fh, '<', $httpdconf ) {
        local $/ = undef;
        my $httpdconf_txt = readline($httpdconf_fh);
        close $httpdconf_fh;
        while ( $httpdconf_txt =~ m/<VirtualHost\s+(\d+\.\d+\.\d+\.\d+):(?:\d+)>/sig ) {
            push @vhost_ipaddrs, $1;
        }
    }

    # uniq IP addrs only
    @vhost_ipaddrs = do {
        my %seen;
        grep { !$seen{$_}++ } @vhost_ipaddrs;
    };

    for my $vhost_ipaddr (@vhost_ipaddrs) {
        my $is_bound = 0;
        for my $local_ipaddr (@local_ipaddrs_list) {
            if ( $vhost_ipaddr eq $local_ipaddr ) {
                $is_bound = 1;
                last;
            }
        }
        if ( $is_bound == 0 ) {
            push @unbound_ipaddrs, $vhost_ipaddr;
        }
    }

    if (@unbound_ipaddrs) {
        print_warn('Apache: ');
        print_warning('httpd.conf has VirtualHosts for these IP addrs, which aren\'t bound to the server:');

        for my $unbound_ipaddr (@unbound_ipaddrs) {
            print_magenta("\t \\_ $unbound_ipaddr");
        }
    }
}

sub check_for_rpm_dist_ver_unknown {
    my $sysinfo_config = '/var/cpanel/sysinfo.config';
    my $is_broken      = 0;

    return if !-e $sysinfo_config;

    if ( open my $file_fh, '<', $sysinfo_config ) {
        while (<$file_fh>) {
            if (/^rpm_dist_ver=unknown$/) {
                $is_broken = 1;
                last;
            }
        }
        close $file_fh;
    }

    if ( $is_broken == 1 ) {
        print_warn("${sysinfo_config}: ");
        print_warning("contains 'rpm_dist_ver=unknown'. Try running '/scripts/gensysinfo' to fix");
    }
}

sub check_for_libkeyutils_malware {
    return if ( $os eq 'freebsd' );

    my $bad_libs;

    ## check for the existence of known illegitimate files
    my @dirs  = qw( /lib /lib64 );
    my @files = qw(
                    libkeyutils.so.1.9
                    libkeyutils-1.2.so.0
                    libkeyutils-1.2.so.2
                    libkeyutils.so.1.3.0
                    libkeyutils.so.1.3.2
                );

    for my $dir (@dirs) {
        for my $file (@files) {
            if ( -f "${dir}/${file}" and !-z "${dir}/${file}" ) {
                $bad_libs .= "\t${dir}/${file}\n";
            }
        }
    }

    if ($bad_libs) {
        print "\n\n";
        print_warn('!! [ LIBKEYUTILS ] !! ');
        print_warning('L1/L2 escalate this ticket to L3');
        print "The following file(s) were found:\n$bad_libs\n";
    }
}

sub check_for_ebury_malware {
    #### check for the existence if illegitimate rpms, like these:
    #
    #  openssh-4.3p2-721.el5_61.65
    #  openssh-5.3p1-209.el6_10.41.x86_64
    #
    #  openssh-clients-4.3p2-721.el5_61.65
    #  openssh-clients-5.3p1-209.el6_10.41.x86_64
    #
    #  openssh-server-4.3p2-721.el5_61.65
    #  openssh-server-5.3p1-209.el6_10.41.x86_64

    my $bad_rpms;

    for my $rpm (@rpm_list) {
        if ( $rpm =~ m{ \A openssh-(clients|server|\d)(.*)-(\d){3}\. }xms ) {
            $bad_rpms .= "\t$rpm\n";
        }
    }

    if ($bad_rpms) {
        print "\n\n";
        print_warn('!! [ EBURY ] !! ');
        print_warning('L1/L2 escalate this ticket to L3');
        print "The following rpm(s) were found:\n$bad_rpms\n";
    }
}

sub check_for_cdorked {
    my $apache_bin = '/usr/local/apache/bin/httpd';
    return if ( !-f $apache_bin );

    my $has_cdorked = 0; 

    if ( open my $file_fh, '<', $apache_bin ) {
        while ( <$file_fh> ) {
            if ( /open_tty/ ) {
                $has_cdorked = 1; 
                last;
            }    
        }    
        close $file_fh;
    }    

    if ( $has_cdorked == 1 ) {
        print_warn('!! [ Linux/Cdorked ] !! ');
        print_warning('L1/L2 escalate this ticket to L3. L3 use 00 - Cdorked premade');
    }    
}

sub check_for_cloudlinux_not_licensed_through_cpanel {
    return if ( $is_cloudlinux == 0 );

    my $host = 'verify.cpanel.net';
    my $url  = '/index.cgi?ip=' . $external_ip_address;
    my $is_licensed_for_cloudlinux_through_cpanel = 0;

    my $sock = IO::Socket::INET->new(
        PeerAddr    => $host,
        PeerPort    => 80,
        Proto       => 'tcp',
        Timeout     => 3,
    ) or return;

    local $SIG{'ALRM'} = sub { return (); };

    print $sock "GET $url HTTP/1.1\r\nHost: verify.cpanel.net\r\n\r\n";
    alarm 3;
    read $sock, my $buffer, 50_000;
    alarm 0;
    close $sock;

    if ( $buffer =~ /cloud_linux_os/ ) {
        $is_licensed_for_cloudlinux_through_cpanel = 1;
    }

    if ( $is_licensed_for_cloudlinux_through_cpanel == 0 ) {
        print_warn('CloudLinux: ');
        print_warning("installed, not licensed by cPanel [ http://verify.cpanel.net/index.cgi?ip=${external_ip_address} ]");
    }
}

# Yes, this actually happened...
sub check_for_cpbackup_exclude_everything {
    my $conf = '/etc/cpbackup-exclude.conf';
    return if ( !-f $conf );

    my $excluding_everything = 0;

    open my $conf_fh, '<', $conf or return;
    while ( <$conf_fh> ) {
        chomp;
        if ( /^\*$/ ) {
            $excluding_everything = 1;
            last;
        }
    }
    close $conf_fh;

    if ( $excluding_everything == 1 ) {
        print_warn('Backups: ');
        print_warning("'*' exists by itself in $conf . This can cause 0 byte backups");
    }
}

sub check_for_nocloudlinux_touchfile {
    if ( -e '/var/cpanel/nocloudlinux' ) {
        print_warn('/var/cpanel/nocloudlinux: ');
        print_warning('exists! CloudLinux cannot be installed when this file is present.');
    }
}

sub check_for_unsupported_options_in_phpini { # case 75397
    my $phpini = '/usr/local/lib/php.ini';
    return if ( !-f $phpini );

    my $unsupported_options;
    if ($php5version) {
        my ( undef, $php5minor ) = split /\./, $php5version;

        return if ($php5minor <= 3);

        if ( open my $file_fh, '<', $phpini ) {
            while ( <$file_fh> ) {
                # http://www.php.net/manual/en/migration54.ini.php
                # apparently "safe_mode = off" won't trigger 75397, but "safe_mode = on" will
                # some items like "y2k_compliance = On" don't appear to trigger the issue
                if ( m{ \A (?:[\s\t]+)? (register_globals|safe_mode) (?:[\s\t]+)? = (?:[\s\t]+)? ["']? on ['"]? }ixms ) {
                    $unsupported_options .= "[$1] ";
                }
            }
            close $file_fh;
        }
        else {
            return;
        }
    }

    if ( $unsupported_options ) {
        $unsupported_options =~ s/\s$//g;
        print_warn("$phpini: ");
        print_warning("PHP $php5version does not support $unsupported_options, but found enabled in php.ini. See FB 75397");
    }
}

##############################
#  END [WARN] CHECKS
##############################

##############################
#  BEGIN [3RDP] CHECKS
##############################


##############################
#  END [3RDP] CHECKS
##############################

sub build_rpm_list {
    return if ( $os eq 'freebsd' );

    my $timeout = 15;

    print_info2("RPM check (running \"rpm -qa ...\"). This will timeout after $timeout seconds.");

    if ( my $pid = open( my $fh, '-|' ) ) {
        local $/ = undef;
        local $SIG{'ALRM'} = sub {
            print_warning('Additional RPM: check timed out');
            kill( 'TERM', $pid );
            sleep(1);
            kill( 9, $pid );
        };
        alarm $timeout;
        @extended_rpm_list = map {
            my ( $arch, $name, $version, $release ) = split( /\t/, $_ );
            {
                'name'    => $name,
                'arch'    => $arch,
                'version' => $version,
                'release' => $release
            }
        } split( /\n/, readline($fh) );

    }
    else {
        exec 'rpm', '-qa', '--queryformat', q{%{ARCH}\t%{NAME}\t%{VERSION}\t%{RELEASE}\n};
        exit 1;
    }

    alarm 0;

    @rpm_list =
      map { $_->{'name'} . '-' . $_->{'version'} . '-' . $_->{'release'} } @extended_rpm_list;

    return @rpm_list;
}

sub cached_run {
    if ( $INC{'Cpanel/CachedCommand.pm'} ) {
        goto \&Cpanel::CachedCommand::cachedcommand;
    }
    else {
        goto \&run;
    }
}

sub check_for_cloudlinux_mysql_gov {
    if ( my @cl_mysql_rpms = grep ( m{^cl-MySQL-}, @rpm_list ) ) {
        print_warn("CloudLinux MySQL (see FB 64017): ");
        print_warning( join( " ", @cl_mysql_rpms ) );
    }
}

1;
